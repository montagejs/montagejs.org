{"name":"frb","version":"0.2.11","description":"Functional reactive bindings","keywords":["functional","reactive","bindings","observe","change"],"author":{"name":"Kris Kowal","email":"kris@cixar.com","url":"http://github.com/kriskowal/"},"contributors":[{"name":"Kris Kowal","email":"kris@cixar.com","url":"http://github.com/kriskowal/"}],"bugs":{"mail":"kris@cixar.com","url":"http://github.com/kriskowal/frb/issues"},"licenses":[{"type":"MIT","url":"http://github.com/kriskowal/frb/raw/master/LICENSE.md"}],"repository":{"type":"git","url":"http://github.com/kriskowal/frb.git"},"main":"bindings","dependencies":{"collections":"~0.1.23"},"devDependencies":{"jasmine-node":"1.x.x","pegjs":"git://github.com/dmajda/pegjs.git"},"scripts":{"test":"jasmine-node spec","build-parser":"pegjs --allowed-start-rules expression,sheet grammar.pegjs"},"readme":"\n<img src=\"frb.png\" align=\"right\" alt=\"FRB Logo\">\n\n# Functional Reactive Bindings\n\nIn their simplest form, bindings provide the illusion that two objects\nhave the same property.  Changing the property on one object causes the\nsame change in the other.  This is useful for coordinating state between\nviews and models, among other entangled objects.  For example, if you\nenter text into a text field, the same text might be added to the\ncorresponding database record.\n\n```javascript\nbind(object, \"a.b\", {\"<->\": \"c.d\"});\n```\n\nFunctional Reactive Bindings go farther.  They can gracefully bind long\nproperty paths and the contents of collections.  They can also\nincrementally update the results of chains of queries including maps,\nflattened arrays, sums, and averages.  They can also add and remove\nelements from sets based on the changes to a flag.  FRB makes it easy to\nincrementally ensure consistent state.\n\n```javascript\nbind(company, \"payroll\", {\"<-\": \"departments.map{employees.sum{salary}}.sum()\"});\nbind(document, \"body.classList.has('dark')\", {\"<-\": \"darkMode\", source: viewModel});\n```\n\nFRB is built from a combination of powerful functional and generic\nbuilding blocks, making it reliable, easy to extend, and easy to\nmaintain.\n\n\n## Getting Started\n\n`frb` is a CommonJS package, with JavaScript modules suitable for use\nwith [Node.js][] on the server side or [Mr][] on the client side. \n\n```\n❯ npm install frb\n```\n\n\n\n\n## Tutorial\n\nIn this example, we bind `model.content` to `document.body.innerHTML`.\n\n```javascript\nvar bind = require(\"frb/bind\");\nvar model = {content: \"Hello, World!\"};\nvar cancelBinding = bind(document, \"body.innerHTML\", {\n    \"<-\": \"content\",\n    \"source\": model\n});\n```\n\nWhen a source property is bound to a target property, the target gets\nreassigned to the source any time the source changes.\n\n```javascript\nmodel.content = \"Farewell.\";\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\nBindings can be recursively detached from the objects they observe with\nthe returned cancel function.\n\n```javascript\ncancelBinding();\nmodel.content = \"Hello again!\"; // doesn't take\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\n### Two-way Bindings\n\nBindings can go one way or in both directions.  Declare one-way\nbindings with the ```<-``` property, and two-way bindings with the\n```<->``` property.\n\nIn this example, the \"foo\" and \"bar\" properties of an object will be\ninexorably intertwined.\n\n```javascript\nvar object = {};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\n\n// <-\nobject.bar = 10;\nexpect(object.foo).toBe(10);\n\n// ->\nobject.foo = 20;\nexpect(object.bar).toBe(20);\n```\n\n### Right-to-left\n\nNote that even with a two-way binding, the right-to-left binding\nprecedes the left-to-right.  In this example, \"foo\" and \"bar\" are bound\ntogether, but both have initial values.\n\n```javascript\nvar object = {foo: 10, bar: 20};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\nexpect(object.foo).toBe(20);\nexpect(object.bar).toBe(20);\n```\n\nThe right-to-left assignment of `bar` to `foo` happens first, so the\ninitial value of `foo` gets lost.\n\n### Properties\n\nBindings can follow deeply nested chains, on both the left and the right\nside.\n\nIn this example, we have two object graphs, `foo`, and `bar`, with the\nsame structure and initial values.  This binds `bar.a.b` to `foo.a.b`\nand also the other way around.\n\n```javascript\nvar foo = {a: {b: 10}};\nvar bar = {a: {b: 10}};\nvar cancel = bind(foo, \"a.b\", {\n    \"<->\": \"a.b\",\n    source: bar\n});\n// <-\nbar.a.b = 20;\nexpect(foo.a.b).toBe(20);\n// ->\nfoo.a.b = 30;\nexpect(bar.a.b).toBe(30);\n```\n\n### Structure changes\n\nChanges to the structure of either side of the binding are no matter.\nAll of the orphaned event listeners will automatically be canceled, and\nthe binders and observers will reattach to the new object graph.\n\nContinuing from the previous example, we store and replace the `a`\nobject from one side of the binding.  The old `b` property is now\norphaned, and the old `b` property adopted in its place.\n\n```javascript\nvar a = foo.a;\nexpect(a.b).toBe(30); // from before\n\nfoo.a = {}; // orphan a and replace\nfoo.a.b = 40;\n// ->\nexpect(bar.a.b).toBe(40); // updated\n\nbar.a.b = 50;\n// <-\nexpect(foo.a.b).toBe(50); // new one updated\nexpect(a.b).toBe(30); // from before it was orphaned\n```\n\n### Sum\n\nSome advanced queries are possible with one-way bindings from\ncollections.  FRB updates sums incrementally.  When values are added or\nremoved from the array, the sum of only those values is taken and added\nor removed from the last known sum.\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"sum\", {\"<-\": \"array.sum()\"});\nexpect(object.sum).toEqual(6);\n```\n\n### Average\n\nThe arithmetic mean of a collection can be updated incrementally.  Each\ntime the array changes, the added and removed values adjust the last\nknown sum and count of values in the array.\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"average\", {\"<-\": \"array.average()\"});\nexpect(object.average).toEqual(2);\n```\n\n### Last\n\nFRB provides an operator for watching the last value in an Array.\n\n```javascript\nvar array = [1, 2, 3];\nvar object = {array: array, last: null};\nBindings.defineBinding(object, \"last\", {\"<-\": \"array.last()\"});\nexpect(object.last).toBe(3);\n\narray.push(4);\nexpect(object.last).toBe(4);\n```\n\nWhen the dust settles, `array.last()` is equivalent to\n`array[array.length - 1]`, but the `last` observer guarantees that it\nwill not jitter between the ultimate value and null or the penultimate\nvalue of the collection.  With `array[array.length]`, the underlying may\nnot change its content and length atomically.\n\n```javascript\nvar changed = jasmine.createSpy();\nPropertyChanges.addOwnPropertyChangeListener(object, \"last\", changed);\narray.unshift(0);\narray.splice(3, 0, 3.5);\nexpect(object.last).toBe(4);\nexpect(changed).not.toHaveBeenCalled();\n\narray.pop();\nexpect(object.last).toBe(3);\n\narray.clear();\nexpect(object.last).toBe(null);\n```\n\n### Map\n\nYou can also create mappings from one array to a new array and an\nexpression to evaluate on each value.  The mapped array is bound once,\nand all changes to the source array are incrementally updated in the\ntarget array.\n\n```javascript\nvar object = {objects: [\n    {number: 10},\n    {number: 20},\n    {number: 30}\n]};\nbind(object, \"numbers\", {\"<-\": \"objects.map{number}\"});\nexpect(object.numbers).toEqual([10, 20, 30]);\nobject.objects.push({number: 40});\nexpect(object.numbers).toEqual([10, 20, 30, 40]);\n```\n\nAny function, like `sum` or `average`, can be applied to the result of a\nmapping.  The straight-forward path would be\n`objects.map{number}.sum()`, but you can use a block with any function\nas a short hand, `objects.sum{number}`.\n\n### Filter\n\nA filter block generates an incrementally updated array filter.  The\nresulting array will contain only those elements from the source array\nthat pass the test deescribed in the block.  As values of the source\narray are added, removed, or changed such that they go from passing to\nfailing or failing to passing, the filtered array gets incrementally\nupdated to include or exclude those values in their proper positions, as\nif the whole array were regenerated with `array.filter` by brute force.\n\n```javascript\nvar object = {numbers: [1, 2, 3, 4, 5, 6]};\nbind(object, \"evens\", {\"<-\": \"numbers.filter{!(%2)}\"});\nexpect(object.evens).toEqual([2, 4, 6]);\nobject.numbers.push(7, 8);\nobject.numbers.shift();\nobject.numbers.shift();\nexpect(object.evens).toEqual([4, 6, 8]);\n```\n\n### Some and Every\n\nA `some` block incrementally tracks whether some of the values in a\ncollection meet a criterion.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    anyChecked: {\n        \"<-\": \"options.some{checked}\"\n    }\n});\nexpect(object.anyChecked).toBe(true);\n```\n\nAn `every` block incrementally tracks whether all of the values in a\ncollection meet a criterion.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    allChecked: {\n        \"<-\": \"options.every{checked}\"\n    }\n});\nexpect(object.allChecked).toBe(false);\n```\n\nYou can use a two-way binding on `some` and `every` blocks.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    allChecked: {\n        \"<->\": \"options.every{checked}\"\n    },\n    noneChecked: {\n        \"<->\": \"!options.some{checked}\"\n    }\n});\n\nobject.noneChecked = true;\nexpect(object.options.every(function (option) {\n    return !option.checked\n}));\n\nobject.allChecked = true;\nexpect(object.noneChecked).toBe(false);\n```\n\nThe caveat of an `equals` binding applies.  If the condition for every\nelement of the collection is set to true, the condition will be bound\nincrementally to true on each element.  When the condition is set to\nfalse, the binding will simply be canceled.\n\n```javascript\nobject.allChecked = false;\nexpect(object.options.every(function (option) {\n    return option.checked; // still checked\n}));\n```\n\n### Sorted\n\nA sorted block generates an incrementally updated sorted array.  The\nresulting array will contain all of the values from the source except in\nsorted order.\n\n```javascript\nvar object = {numbers: [5, 2, 7, 3, 8, 1, 6, 4]};\nbind(object, \"sorted\", {\"<-\": \"numbers.sorted{}\"});\nexpect(object.sorted).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n```\n\nThe block may specify a property or expression by which to compare\nvalues.\n\n```javascript\nvar object = {arrays: [[1, 2, 3], [1, 2], [], [1, 2, 3, 4], [1]]};\nbind(object, \"sorted\", {\"<-\": \"arrays.sorted{-length}\"});\nexpect(object.sorted.map(function (array) {\n    return array.slice(); // to clone\n})).toEqual([\n    [1, 2, 3, 4],\n    [1, 2, 3],\n    [1, 2],\n    [1],\n    []\n]);\n```\n\nThe sorted binding responds to changes to the sorted property by\nremoving them at their former place and adding them back at their new\nposition.\n\n```javascript\nobject.arrays[0].push(4, 5);\nexpect(object.sorted.map(function (array) {\n    return array.slice(); // to clone\n})).toEqual([\n    [1, 2, 3, 4, 5], // new\n    [1, 2, 3, 4],\n    // old\n    [1, 2],\n    [1],\n    []\n]);\n```\n\n### Min and Max\n\nA binding can observe the minimum or maximum of a collection.  FRB uses\na binary heap internally to incrementally track the minimum or maximum\nvalue of the collection.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    min: {\"<-\": \"values.min{}\"},\n    max: {\"<-\": \"values.max{}\"}\n});\n\nexpect(object.min).toBe(undefined);\nexpect(object.max).toBe(undefined);\n\nobject.values = [2, 3, 2, 1, 2];\nexpect(object.min).toBe(1);\nexpect(object.max).toBe(3);\n```\n\nMin and max blocks accept an expression on which to compare values from\nthe collection.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    loser: {\"<-\": \"rounds.min{score}.player\"},\n    winner: {\"<-\": \"rounds.max{score}.player\"}\n});\n\nobject.rounds = [\n    {score: 0, player: \"Luke\"},\n    {score: 100, player: \"Obi Wan\"},\n    {score: 250, player: \"Vader\"}\n];\nexpect(object.loser).toEqual(\"Luke\");\nexpect(object.winner).toEqual(\"Vader\");\n\nobject.rounds[1].score = 300;\nexpect(object.winner).toEqual(\"Obi Wan\");\n```\n\n### Group\n\nFRB can incrementally track equivalence classes within in a collection.\nThe group block accepts an expression that determines the equivalence\nclass for each object in a collection.  The result is a nested data\nstructure: an array of [key, class] pairs, where each class is itself an\narray of all members of the collection that have the corresponding key.\n\n```javascript\nvar store = Bindings.defineBindings({}, {\n    \"clothingByColor\": {\"<-\": \"clothing.group{color}\"}\n});\nstore.clothing = [\n    {type: 'shirt', color: 'blue'},\n    {type: 'pants', color: 'red'},\n    {type: 'blazer', color: 'blue'},\n    {type: 'hat', color: 'red'}\n];\nexpect(store.clothingByColor).toEqual([\n    ['blue', [\n        {type: 'shirt', color: 'blue'},\n        {type: 'blazer', color: 'blue'}\n    ]],\n    ['red', [\n        {type: 'pants', color: 'red'},\n        {type: 'hat', color: 'red'}\n    ]]\n]);\n```\n\nTracking the positions of every key and every value in its equivalence\nclass can be expensive.  Internally, `group` blocks are implemented with\na `groupMap` block followed by an `entries()` observer.  The `groupMap`\nproduces a `Map` data structure and does not waste any time, but does\nnot produce range change events.  The `entries()` observer projects the\nmap of classes into the nested array data structure.\n\nYou can use the `groupMap` block directly.\n\n```javascript\nBindings.cancelBinding(store, \"clothingByColor\");\nBindings.defineBindings(store, {\n    \"clothingByColor\": {\"<-\": \"clothing.groupMap{color}\"}\n});\nvar blueClothes = store.clothingByColor.get('blue');\nexpect(blueClothes).toEqual([\n    {type: 'shirt', color: 'blue'},\n    {type: 'blazer', color: 'blue'}\n]);\n\nstore.clothing.push({type: 'gloves', color: 'blue'});\nexpect(blueClothes).toEqual([\n    {type: 'shirt', color: 'blue'},\n    {type: 'blazer', color: 'blue'},\n    {type: 'gloves', color: 'blue'}\n]);\n```\n\nThe `group` and `groupMap` blocks both respect the type of the source\ncollection.  If instead of an array you were to use a `SortedSet`, the\nequivalence classes would each be sorted sets.  This is useful because\nreplacing values in a sorted set can be performed with much less waste\nthan with a large array.\n\n### View\n\nSuppose that your source is a large data store, like a `SortedSet` from\nthe [Collections][] package.  You might need to view a sliding window\nfrom that collection as an array.  The `view` binding reacts to changes\nto the collection and the position and length of the window.\n\n```javascript\nvar SortedSet = require(\"collections/sorted-set\");\nvar controller = {\n    index: SortedSet([1, 2, 3, 4, 5, 6, 7, 8]),\n    start: 2,\n    length: 4\n};\nvar cancel = bind(controller, \"view\", {\n    \"<-\": \"index.view(start, length)\"\n});\n\nexpect(controller.view).toEqual([3, 4, 5, 6]);\n\n// change the window length\ncontroller.length = 3;\nexpect(controller.view).toEqual([3, 4, 5]);\n\n// change the window position\ncontroller.start = 5;\nexpect(controller.view).toEqual([6, 7, 8]);\n\n// add content behind the window\ncontroller.index.add(0);\nexpect(controller.view).toEqual([5, 6, 7]);\n```\n\n### Enumerate\n\nAn enumeration observer produces `[index, value]` pairs.  You can bind\nto the index or the value in subsequent stages.  The prefix dot\ndistinguishes the zeroeth property from the literal zero.\n\n```javascript\nvar object = {letters: ['a', 'b', 'c', 'd']};\nbind(object, \"lettersAtEvenIndexes\", {\n    \"<-\": \"letters.enumerate().filter{!(.0 % 2)}.map{.1}\"\n});\nexpect(object.lettersAtEvenIndexes).toEqual(['a', 'c']);\nobject.letters.shift();\nexpect(object.lettersAtEvenIndexes).toEqual(['b', 'd']);\n```\n\n### Range\n\nA range observes a given length and produces and incrementally updates\nan array of consecutive integers starting with zero with that given\nlength.\n\n```javascript\nvar object = Bindings.defineBinding({}, \"stack\", {\n    \"<-\": \"&range(length)\"\n});\nexpect(object.stack).toEqual([]);\n\nobject.length = 3;\nexpect(object.stack).toEqual([0, 1, 2]);\n\nobject.length = 1;\nexpect(object.stack).toEqual([0]);\n```\n\n### Flatten\n\nYou can flatten nested arrays.  In this example, we have an array of\narrays and bind it to a flat array.\n\n```javascript\nvar arrays = [[1, 2, 3], [4, 5, 6]];\nvar object = {};\nbind(object, \"flat\", {\n    \"<-\": \"flatten()\",\n    source: arrays\n});\nexpect(object.flat).toEqual([1, 2, 3, 4, 5, 6]);\n```\n\nNote that changes to the inner and outer arrays are both projected into\nthe flattened array.\n\n```javascript\narrays.push([7, 8, 9]);\narrays[0].unshift(0);\nexpect(object.flat).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n```\n\nAlso, as with all other bindings that produce arrays, the flattened\narray is never replaced, just incrementally updated.\n\n```javascript\nvar flat = object.flat;\narrays.splice(0, arrays.length);\nexpect(object.flat).toBe(flat); // === same object\n```\n\n### Concat\n\nYou can observe the concatenation of collection of dynamic arrays.\n\n```javascript\nvar object = Bindings.defineBinding({\n    head: 10,\n    tail: [20, 30]\n}, \"flat\", {\n    \"<-\": \"[head].concat(tail)\"\n});\nexpect(object.flat).toEqual([10, 20, 30]);\n```\n\nThe underlying mechanism is equivalent to `[[head], tail].flatten()`.\n\n### Reversed\n\nYou can bind the reversal of an array.\n\n```javascript\nvar object = {forward: [1, 2, 3]};\nbind(object, \"backward\", {\n    \"<->\": \"forward.reversed()\"\n});\nexpect(object.backward.slice()).toEqual([3, 2, 1]);\nobject.forward.push(4);\nexpect(object.forward.slice()).toEqual([1, 2, 3, 4]);\nexpect(object.backward.slice()).toEqual([4, 3, 2, 1]);\n```\n\nNote that you can do two-way bindings, ```<->``` with reversed arrays.\nChanges to either side are updated to the opposite side.\n\n```javascript\nobject.backward.pop();\nexpect(object.backward.slice()).toEqual([4, 3, 2]);\nexpect(object.forward.slice()).toEqual([2, 3, 4]);\n```\n\n### Has\n\nYou can bind a property to always reflect whether a collection contains\na particular value.\n\n```javascript\nvar object = {\n    haystack: [1, 2, 3],\n    needle: 3\n};\nbind(object, \"hasNeedle\", {\"<-\": \"haystack.has(needle)\"});\nexpect(object.hasNeedle).toBe(true);\nobject.haystack.pop(); // 3 comes off\nexpect(object.hasNeedle).toBe(false);\n```\n\nThe binding also reacts to changes to the value you seek.\n\n```javascript\n// Continued from above...\nobject.needle = 2;\nexpect(object.hasNeedle).toBe(true);\n```\n\n`has` bindings are not incremental, but with the right data-structure,\nupdates are cheap.  The [Collections][] package contains Lists, Sets,\nand OrderedSets that all can send content change notifications and thus\ncan be bound.\n\n```javascript\n// Continued from above...\nvar Set = require(\"collections/set\");\nobject.haystack = new Set([1, 2, 3]);\nexpect(object.hasNeedle).toBe(true);\n```\n\n`has` bindings can also be left-to-right and bi-directional.\n\n```javascript\nbind(object, \"hasNeedle\", {\"<->\": \"haystack.has(needle)\"});\nobject.hasNeedle = false;\nexpect(object.haystack.has(2)).toBe(false);\n```\n\nThe collection on the left-hand-side must implement `has` or `contains`,\n`add`, and `delete` or `remove`.  FRB shims `Array` to have `has`,\n`add`, and `delete`, just like all the collections in [Collections][].\nIt happens that the `classList` properties of DOM elements, when they\nare supported, implement `add`, `remove`, and `contains`.\n\n```javascript\nvar model = {darkMode: false};\nbind(document.body, \"classList.has('dark')\", {\n    \"<-\": \"darkMode\",\n    source: model\n});\n```\n\nThe DOM `classList` does not however implement\n`addContentChangeListener` or `removeContentChangeListener`, so it\ncannot be used on the right-hand-side of a binding, and such bindings\ncannot be bidirectional.  With some DOM [Mutation Observers][], you\nmight be able to help FRB overcome this limitation in the future.\n\n### Get\n\nA binding can observe changes in key-to-value mappings in arrays and map\n[Collections][].\n\n```javascript\nvar object = {\n    array: [1, 2, 3],\n    second: null\n};\nvar cancel = bind(object, \"second\", {\n    \"<->\": \"array.get(1)\"\n});\nexpect(object.array.slice()).toEqual([1, 2, 3]);\nexpect(object.second).toBe(2);\n\nobject.array.shift();\nexpect(object.array.slice()).toEqual([2, 3]);\nexpect(object.second).toBe(3);\n\nobject.second = 4;\nexpect(object.array.slice()).toEqual([2, 4]);\n\ncancel();\nobject.array.shift();\nexpect(object.second).toBe(4); // still\n```\n\nThe source collection can be a Map, Dict, MultiMap, SortedMap,\nSortedArrayMap, or anything that implements `get` and\n`addMapChangeListener` as specified in [Collections][].  The key can\nalso be a variable.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar a = {id: 0}, b = {id: 1};\nvar object = {\n    source: Map([[a, 10], [b, 20]]),\n    key: null,\n    selected: null\n};\n\nvar cancel = bind(object, \"selected\", {\n    \"<-\": \"source.get(key)\"\n});\nexpect(object.selected).toBe(undefined);\n\nobject.key = a;\nexpect(object.selected).toBe(10);\n\nobject.key = b;\nexpect(object.selected).toBe(20);\n\nobject.source.set(b, 30);\nexpect(object.selected).toBe(30);\n\nvar SortedMap = require(\"collections/sorted-map\");\nobject.source = SortedMap();\nexpect(object.selected).toBe(undefined);\n\nobject.source.set(b, 40);\nexpect(object.selected).toBe(40);\n\ncancel();\nobject.key = a; // no effect\nexpect(object.selected).toBe(40);\n```\n\nYou can also bind the entire content of a map-like collection to the\ncontent of another.  Bear in mind that the content of the source\nreplaces the content of the target initially.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = {\n    a: Map({a: 10}),\n    b: Map()\n};\nvar cancel = bind(object, \"a.mapContent()\", {\"<->\": \"b.mapContent()\"});\nexpect(object.a.toObject()).toEqual({});\nexpect(object.b.toObject()).toEqual({});\n\nobject.a.set('a', 10);\nexpect(object.a.toObject()).toEqual({a: 10});\nexpect(object.b.toObject()).toEqual({a: 10});\n\nobject.b.set('b', 20);\nexpect(object.a.toObject()).toEqual({a: 10, b: 20});\nexpect(object.b.toObject()).toEqual({a: 10, b: 20});\n```\n\nIn this case, the source of the binding is a different object than the\ntarget, so the binding descriptor specifies the alternate source.\n\n### Keys, Values, Entries\n\nIf the source of a binding is a map, FRB can also translate changes to\nthe map into changes on an array.  The `keys`, `values`, and `entries`\nobservers produce incrementally updated projections of the\nkey-value-mappings onto an array.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = Bindings.defineBindings({}, {\n    keys: {\"<-\": \"map.keys()\"},\n    values: {\"<-\": \"map.values()\"},\n    entries: {\"<-\": \"map.entries()\"}\n});\nobject.map = Map({a: 10, b: 20, c: 30});\nexpect(object.keys).toEqual(['a', 'b', 'c']);\nexpect(object.values).toEqual([10, 20, 30]);\nexpect(object.entries).toEqual([['a', 10], ['b', 20], ['c', 30]]);\n\nobject.map.set('d', 40);\nobject.map.delete('a');\nexpect(object.keys).toEqual(['b', 'c', 'd']);\nexpect(object.values).toEqual([20, 30, 40]);\nexpect(object.entries).toEqual([['b', 20], ['c', 30], ['d', 40]]);\n```\n\n### Coerce to Map\n\nRecords (Objects with a fixed shape), arrays of entries, and Maps\nthemselves can be coerced to an incrementally updated `Map` with the\n`toMap` operator.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    map: {\"<-\": \"entries.toMap()\"}\n});\n\n// map property will persist across changes to entries\nvar map = object.map;\nexpect(map).not.toBe(null);\n\nobject.entries = {a: 10};\nexpect(map.keys()).toEqual(['a']);\nexpect(map.has('a')).toBe(true);\nexpect(map.get('a')).toBe(10);\n```\n\nThe `toMap` observer maintains the insertion order of the keys.\n\n```javascript\n// Continued...\nobject.entries = [['b', 20], ['c', 30]];\nexpect(map.keys()).toEqual(['b', 'c']);\n\nobject.entries.push(object.entries.shift());\nexpect(map.keys()).toEqual(['c', 'b']);\n```\n\nIf the entries do not have unique keys, the last entry wins.  This is\nmanaged internally by observing, `entries.group{.0}.map{.1.last()}`.\n\n```javascript\n// Continued...\nobject.entries = [['a', 10], ['a', 20]];\nexpect(map.get('a')).toEqual(20);\nobject.entries.pop();\nexpect(map.get('a')).toEqual(10);\n```\n\n`toMap` binds the content of the output map to the content of the input\nmap and will clear and repopulate the output map if the input map is\nreplaced.\n\n```\n// Continued...\nobject.entries = new Map({a: 10});\nexpect(map.keys()).toEqual(['a']);\n```\n\n### Equals\n\nYou can bind to whether expressions are equal.\n\n```javascript\nvar fruit = {apples: 1, oranges: 2};\nbind(fruit, \"equal\", {\"<-\": \"apples == oranges\"});\nexpect(fruit.equal).toBe(false);\nfruit.orange = 1;\nexpect(fruit.equal).toBe(true);\n```\n\nEquality can be bound both directions.  In this example, we do a two-way\nbinding between whether a radio button is checked and a corresponding\nvalue in our model.\n\n```javascript\nvar component = {\n    orangeElement: {checked: false},\n    appleElement: {checked: true}\n};\nBindings.defineBindings(component, {\n    \"orangeElement.checked\": {\"<->\": \"fruit == 'orange'\"},\n    \"appleElement.checked\": {\"<->\": \"fruit == 'apple'\"},\n});\n\ncomponent.orangeElement.checked = true;\nexpect(component.fruit).toEqual(\"orange\");\n\ncomponent.appleElement.checked = true;\nexpect(component.fruit).toEqual(\"apple\");\n```\n\nBecause equality and assignment are interchanged in this language, you\ncan use either `=` or `==`.\n\nFRB also supports a comparison operator, `<=>`, which uses\n`Object.compare` to determines how two operands should be sorted in\nrelation to each other.\n\n### Array and Map Content\n\nIn JavaScript, arrays behave both like objects (in the sense that every\nindex is a property, but also like a map collection of index-to-value\npairs.  The [Collections][] package goes so far as to patch up the\n`Array` prototype so arrays can masquerade as maps, with the caveat that\n`delete(value)` behaves like a Set instead of a Map.\n\nThis duplicity is reflected in FRB.  You can access the values in an\narray using the object property notation or the mapped key notation.\n\n```javascript\nvar object = {\n    array: [1, 2, 3]\n};\nBindings.defineBindings(object, {\n    first: {\"<-\": \"array.0\"},\n    second: {\"<-\": \"array.get(1)\"}\n});\nexpect(object.first).toBe(1);\nexpect(object.second).toBe(2);\n```\n\nTo distinguish a numeric property of the source from a number literal,\nuse a dot.  To distingish a mapped index from an array literal, use an\nempty expression.\n\n```javascript\nvar array = [1, 2, 3];\nvar object = {};\nBindings.defineBindings(object, {\n    first: {\n        \"<-\": \".0\",\n        source: array\n    },\n    second: {\n        \"<-\": \"get(1)\",\n        source: array\n    }\n});\nexpect(object.first).toBe(1);\nexpect(object.second).toBe(2);\n```\n\nUnlike property notation, map notation can observe a variable index.\n\n```javascript\nvar object = {\n    array: [1, 2, 3],\n    index: 0\n};\nBindings.defineBinding(object, \"last\", {\n    \"<-\": \"array.get(array.length - 1)\"\n});\nexpect(object.last).toBe(3);\n\nobject.array.pop();\nexpect(object.last).toBe(2);\n```\n\nYou can also bind *all* of the content of an array by range or by\nmapping.  The notation for binding ranged content is `rangeContent()`.\nEvery change to an Array or SortedSet dispatches range changes and any\ncollection that implements `splice` and `swap` can be a target for such\nchanges.\n\n```javascript\nvar SortedSet = require(\"collections/sorted-set\");\nvar object = {\n    set: SortedSet(),\n    array: []\n};\nBindings.defineBindings(object, {\n    \"array.rangeContent()\": {\"<-\": \"set\"}\n});\nobject.set.addEach([5, 2, 6, 1, 4, 3]);\nexpect(object.array).toEqual([1, 2, 3, 4, 5, 6]);\n```\n\nThe notation for binding the content of any mapping collection using map\nchanges is `mapContent()`.  On the target of a binding, this will note\nwhen values are added or removed on each key of the source collection\nand apply the same change to the target.  The target and source can be\narrays or map collections.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = {\n    map: Map(),\n    array: []\n};\nBindings.defineBinding(object, \"map.mapContent()\", {\n    \"<-\": \"array\"\n});\nobject.array.push(1, 2, 3);\nexpect(object.map.toObject()).toEqual({\n    0: 1,\n    1: 2,\n    2: 3\n});\n```\n\n### Value\n\nA note about the source value: an empty path implies the source value.\nUsing empty paths and empty expressions is useful in some situations.\n\nIf a value is ommitted on either side of an operator, it implies the\nsource value.  The expression `sorted{}` indicates a sorted array, where\neach value is sorted by its own numeric value.  The expression\n`filter{!!}` would filter falsy values.  The operand is implied.\nSimilarly, `filter{!(%2)}` produces only even values.\n\nThis is why you can use `.0` to get the zeroth property of an array, to\ndistingiush the form from `0` which would be a numeric literal, and why\nyou can use `()[0]` to map the zeroeth key of a map or array, to\ndistinguish the form from `[0]` which would be an array literal.\n\n### With Context Value\n\nExpressions can be evaluated in the context of another value using a\nvariant of property notation.  A parenthesized expression can follow a\npath.\n\n```javascript\nvar object = {\n    context: {a: 10, b: 20}\n};\nBindings.defineBinding(object, \"sum\", {\n    \"<-\": \"context.(a + b)\"\n});\nexpect(object.sum).toBe(30);\n\nBindings.cancelBinding(object, \"sum\");\nobject.context.a = 20;\nexpect(object.sum).toBe(30); // unchanged\n```\n\nTo observe a constructed array or object literal, the expression does\nnot need parentheses.\n\n```javascript\nvar object = {\n    context: {a: 10, b: 20}\n};\nBindings.defineBindings(object, {\n    \"duple\": {\"<-\": \"context.[a, b]\"},\n    \"pair\": {\"<-\": \"context.{key: a, value: b}\"}\n});\nexpect(object.duple).toEqual([10, 20]);\nexpect(object.pair).toEqual({key: 10, value: 20});\n\nBindings.cancelBindings(object);\n```\n\n### Operators\n\nFRB can also recognize many operators.  These are in order of precedence\nunary `-` negation, `+` numeric coercion, and `!` logical negation and\nthen binary `**` power, `//` root, `%%` logarithm, `*`, `/`, `%` modulo,\n`%%` remainder, `+`, `-`, ```<```, ```>```, ```<=```, ```>=```, `=` or\n`==`, `!=`, `&&` and `||`.\n\n```javascript\nvar object = {height: 10};\nbind(object, \"heightPx\", {\"<-\": \"height + 'px'\"});\nexpect(object.heightPx).toEqual(\"10px\");\n```\n\nThe unary `+` operator coerces a value to a number. It is handy for\nbinding a string to a number.\n\n```javascript\nvar object = {\n    number: null,\n    string: null,\n};\nBindings.defineBinding(object, \"+number\", {\n    \"<-\": \"string\"\n});\nobject.string = '10';\nexpect(object.number).toBe(10);\n```\n\n### Functions\n\nFRB supports some common functions.  `startsWith`, `endsWith`, and\n`contains` all operate on strings.  `join` concatenates an array of\nstrings with a given delimiter (or empty string).  `split` breaks a\nstring between every delimiter (or just between every character).\n\n### Conditional\n\nFRB supports the ternary conditional operator, if `?` then `:` else.\n\n```javascript\nvar object = Bindings.defineBindings({\n    condition: null,\n    consequent: 10,\n    alternate: 20\n}, {\n    choice: {\"<->\": \"condition ? consequent : alternate\"}\n});\n\nexpect(object.choice).toBe(undefined); // no choice made\n\nobject.condition = true;\nexpect(object.choice).toBe(10);\n\nobject.condition = false;\nexpect(object.choice).toBe(20);\n```\n\nThe ternary operator can bind in both directions.\n\n```javascript\nobject.choice = 30;\nexpect(object.alternate).toBe(30);\n\nobject.condition = true;\nobject.choice = 40;\nexpect(object.consequent).toBe(40);\n```\n\n### Algebra\n\nFRB can automatically invert algebraic operators as long as they operate\nstrictly on numbers and the left-most expressions on both the source and\ntarget are bindable properties.\n\nIn this example, the primary binding is ```notToBe <- !toBe```, and the\ninverse binding is automatically computed ```toBe <- !notToBe```.\n\n```javascript\nvar caesar = {toBe: false};\nbind(caesar, \"notToBe\", {\"<->\": \"!toBe\"});\nexpect(caesar.toBe).toEqual(false);\nexpect(caesar.notToBe).toEqual(true);\n\ncaesar.notToBe = false;\nexpect(caesar.toBe).toEqual(true);\n```\n\nFRB does algebra by rotating the expressions on one side of a binding to\nthe other until only one independent property remains (the left most\nexpression) on the target side of the equation.\n\n```\nconvert: y <- !x\nrevert: x <- !y\n```\n\n```\nconvert: y <- x + a\nrevert: x <- y - a\n```\n\nThe left-most independent variable on the right hand side becomes the\ndependent variable on the inverted binding.  At present, this only works\nfor numbers and when the left-most expression is a bindable property\nbecause it cannot assign a new value to the literal 10.  For example,\nFRB cannot yet implicitly revert ```y <-> 10 + x```.\n\n### Literals\n\nYou may have noticed literals in the previous examples.  String literals\ntake the form of any characters between single quotes.  Any character\ncan be escaped with a back slash.\n\n```javascript\nvar object = {};\nbind(object, \"greeting\", {\"<-\": \"'Hello, World!'\"});\nexpect(object.greeting).toBe(\"Hello, World!\");\n```\n\nNumber literals are digits with an optional mantissa.\n\n```javascript\nbind(object, 'four', {\"<-\": \"2 + 2\"});\n```\n\n### Tuples\n\nBindings can produce fixed-length arrays.  These are most useful in\nconjunction with mappings.  Tuples are comma-delimited and\nparantheses-enclosed.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\"<-\": \"array.map{[length, sum()]}\"});\nexpect(object.summary).toEqual([\n    [3, 6],\n    [2, 9]\n]);\n```\n\n### Records\n\nBindings can also produce fixed-shape objects.  The notation is\ncomma-delimited, colon-separated entries, enclosed by curly-braces.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\n    \"<-\": \"array.map{{length: length, sum: sum()}}\"\n});\nexpect(object.summary).toEqual([\n    {length: 3, sum: 6},\n    {length: 2, sum: 9}\n]);\n```\n\nThe left hand side of an entry in a record is any combination of letters\nor numbers.  The right side is any expression.\n\n### Parameters\n\nBindings can also involve parameters.  The source of parameters is by\ndefault the same as the source.  The source, in turn, defaults to the\nsame as the target object.  It can be specified on the binding\ndescriptor.  Parameters are declared by any expression following a\ndollar sign.\n\n```javascript\nvar object = {a: 10, b: 20, c: 30};\nbind(object, \"foo\", {\n    \"<-\": \"[$a, $b, $c]\"},\n    parameters: object\n});\n```\n\nBindings also react to changes to the parameters.\n\n```javascript\nobject.a = 0;\nobject.b = 1;\nobject.c = 2;\nexpect(object.foo).toEqual([0, 1, 2]);\n```\n\nThe degenerate case of the property language is an empty string.  This\nis a valid property path that observes the value itself.  So, as an\nemergent pattern, a `$` expression by itself corresponds to the whole\nparameters object.\n\n```javascript\nvar object = {};\nbind(object, \"ten\", {\"<-\": \"$\", parameters: 10});\nexpect(object.ten).toEqual(10);\n```\n\n### Elements and Components\n\nFRB provides a `#` notation for reaching into the DOM for an element.\nThis is handy for binding views and models on a controller object.\n\nThe `defineBindings` method accepts an optional final argument,\n`parameters`, which is shared by all bindings (unless shadowed by a more\nspecific parameters object on an individual descriptor).\n\nThe `parameters` can include a `document`.  The `document` may be any\nobject that implements `getElementById`.\n\nAdditionally, the `frb/dom` is an experiment that monkey-patches the DOM\nto make some properties of DOM elements observable, like the `value` or\n`checked` attribute of an `input` or `textarea element`.\n\n```javascript\nvar Bindings = require(\"frb\");\nrequire(\"frb/dom\");\n\nvar controller = Bindings.defineBindings({}, {\n\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"},\n\n    \"#fahrenheit.value\": {\"<->\": \"+fahrenheit\"},\n    \"#celsius.value\": {\"<->\": \"+celsius\"},\n    \"#kelvin.value\": {\"<->\": \"+kelvin\"}\n\n}, {\n    document: document\n});\n\ncontroller.celsius = 0;\n```\n\nOne caveat of this approach is that it can cause a lot of DOM repaint\nand reflow events.  The [Montage][] framework uses a synchronized draw\ncycle and a component object model to minimize the cost of computing CSS\nproperties on the DOM and performing repaints and reflows, deferring\nsuch operations to individual animation frames.\n\nFor a future release of Montage, FRB provides an alternate notation for\nreaching into the component object model, using its deserializer.  The\n`@` prefix refers to another component by its label.  Instead of\nproviding a `document`, Montage provides a `serialization`, which in\nturn implements `getObjectForLabel`.\n\n```javascript\nvar Bindings = require(\"frb\");\n\nvar controller = Bindings.defineBindings({}, {\n\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"},\n\n    \"@fahrenheit.value\": {\"<->\": \"+fahrenheit\"},\n    \"@celsius.value\": {\"<->\": \"+celsius\"},\n    \"@kelvin.value\": {\"<->\": \"+kelvin\"}\n\n}, {\n    serializer: serializer\n});\n\ncontroller.celsius = 0;\n```\n\n### Observers\n\nFRB’s bindings use observers and binders internally.  You can create an\nobserver from a property path with the `observe` function exported by\nthe `frb/observe` module.\n\n```javascript\nvar results = [];\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", function (value) {\n    results.push(value);\n});\n\nobject.foo.bar = 10;\nexpect(results).toEqual([10]);\n\nobject.foo.bar = 20;\nexpect(results).toEqual([10, 20]);\n```\n\nFor more complex cases, you can specify a descriptor instead of the\ncallback.  For example, to observe a property’s value *before it changes*, you can use the `beforeChange` flag.\n\n```javascript\nvar results = [];\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", {\n    change: function (value) {\n        results.push(value);\n    },\n    beforeChange: true\n});\n\nexpect(results).toEqual([10]);\n\nobject.foo.bar = 20;\nexpect(results).toEqual([10, 10]);\n\nobject.foo.bar = 30;\nexpect(results).toEqual([10, 10, 20]);\n```\n\nIf the product of an observer is an array, that array is always updated\nincrementally.  It will only get emitted once.  If you want it to get\nemitted every time its content changes, you can use the `contentChange`\nflag.\n\n```javascript\nvar lastResult;\nvar array = [[1, 2, 3], [4, 5, 6]];\nobserve(array, \"map{sum()}\", {\n    change: function (sums) {\n        lastResult = sums.slice();\n        // 1. [6, 15]\n        // 2. [6, 15, 0]\n        // 3. [10, 15, 0]\n    },\n    contentChange: true\n});\n\nexpect(lastResult).toEqual([6, 15]);\n\narray.push([0]);\nexpect(lastResult).toEqual([6, 15, 0]);\n\narray[0].push(4);\nexpect(lastResult).toEqual([10, 15, 0]);\n```\n\n### Nested Observers\n\nTo get the same effect as the previous example, you would have to nest\nyour own content change observer.\n\n```javascript\nvar i = 0;\nvar array = [[1, 2, 3], [4, 5, 6]];\nvar cancel = observe(array, \"map{sum()}\", function (array) {\n    function contentChange() {\n        if (i === 0) {\n            expect(array.slice()).toEqual([6, 15]);\n        } else if (i === 1) {\n            expect(array.slice()).toEqual([6, 15, 0]);\n        } else if (i === 2) {\n            expect(array.slice()).toEqual([10, 15, 0]);\n        }\n        i++;\n    }\n    contentChange();\n    array.addContentChangeListener(contentChange);\n    return function cancelContentChange() {\n        array.removeContentChangeListener(contentChange);\n    };\n});\narray.push([0]);\narray[0].push(4);\ncancel();\n```\n\nThis illustrates one crucial aspect of the architecture.  Observers\nreturn cancelation functions.  You can also return a cancelation\nfunction inside a callback observer.  That canceler will get called each\ntime a new value is observed, or when the parent observer is canceled.\nThis makes it possible to nest observers.\n\n```javascript\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo\", function (foo) {\n    return observe(foo, \"bar\", function (bar) {\n        expect(bar).toBe(10);\n    });\n});\n```\n\n### Bindings\n\nFRB provides utilities for declaraing and managing multiple bindings on\nobjects.  The `frb` (`frb/bindings`) module exports this interface.\n\n```javascript\nvar Bindings = require(\"frb\");\n```\n\nThe `Bindings` module provides `defineBindings` and `cancelBindings`,\n`defineBinding` and `cancelBinding`, as well as binding inspector\nmethods `getBindings` and `getBinding`.  All of these take a target\nobject as the first argument.\n\nThe `Bindings.defineBinding(target, descriptors)` method returns the\ntarget object for convenience.\n\n```javascript\nvar target = Bindings.defineBindings({}, {\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"}\n});\ntarget.celsius = 0;\nexpect(target.fahrenheit).toEqual(32);\nexpect(target.kelvin).toEqual(272.15);\n```\n\n`Bindings.getBindings` in that case would return an object with\n`fahrenheit` and `celsius` keys.  The values would be identical to the\ngiven binding descriptor objects, like `{\"<->\": \"kelvin - 272.15\"}`, but\nit also gets annotated with a `cancel` function and the default values\nfor any ommitted properties like `source` (same as `target`),\n`parameters` (same as `source`), and others.\n\n`Bindings.cancelBindings` cancels all bindings attached to an object and\nremoves them from the bindings descriptors object.\n\n```javascript\nBindings.cancelBindings(target);\nexpect(Bindings.getBindings(object)).toEqual({});\n```\n\n### Binding Descriptors\n\nBinding descriptors describe the source of a binding and additional\nparameters.  `Bindings.defineBindings` can set up bindings (```<-``` or\n```<->```), computed (```compute```) properties, and falls back to\ndefining ES5 properties with permissive defaults (`enumerable`,\n`writable`, and `configurable` all on by default).\n\nIf a descriptor has a ```<-``` or ```<->```, it is a binding descriptor.\nFRB creates a binding, adds the canceler to the descriptor, and adds the\ndescriptor to an internal table that tracks all of the bindings defined\non that object.\n\n```javascript\nvar object = Bindings.defineBindings({\n    darkMode: false,\n    document: document\n}, {\n    \"document.body.classList.has('dark')\": {\n        \"<-\": \"darkMode\"\n    }\n});\n```\n\nYou can get all the binding descriptors with `Bindings.getBindings`, or a\nsingle binding descriptor with `Bindings.getBinding`.  `Bindings.cancel` cancels\nall the bindings to an object and `Bindings.cancelBinding` will cancel just\none.\n\n```javascript\n// Continued from above...\nvar bindings = Bindings.getBindings(object);\nvar descriptor = Bindings.getBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancelBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancelBindings(object);\nexpect(Object.keys(bindings)).toEqual([]);\n```\n\n### Converters\n\nA binding descriptor can have a `convert` function, a `revert` function,\nor alternately a `converter` object.  Converters are useful for\ntransformations that cannot be expressed in the property language, or\nare not reversible in the property language.\n\nIn this example, `a` and `b` are synchronized such that `a` is always\nhalf of `b`, regardless of which property gets updated.\n\n```javascript\nvar object = Bindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<->\": \"a\",\n        convert: function (a) {\n            return a * 2;\n        },\n        revert: function (b) {\n            return b / 2;\n        }\n    }\n});\nexpect(object.b).toEqual(20);\n\nobject.b = 10;\nexpect(object.a).toEqual(5);\n```\n\nConverter objects are useful for reusable or modular converter types and\nconverters that track additional state.\n\n```javascript\nfunction Multiplier(factor) {\n    this.factor = factor;\n}\nMultiplier.prototype.convert = function (value) {\n    return value * this.factor;\n};\nMultiplier.prototype.revert = function (value) {\n    return value / this.factor;\n};\n\nvar doubler = new Multiplier(2);\n\nvar object = Bindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<->\": \"a\",\n        converter: doubler\n    }\n});\nexpect(object.b).toEqual(20);\n\nobject.b = 10;\nexpect(object.a).toEqual(5);\n```\n\nReusable converters have an implied direction, from some source type to\na particular target type.  Sometimes the types on your binding are the\nother way around.  For that case, you can use the converter as a\nreverter.  This merely swaps the `convert` and `revert` methods.\n\n```javascript\nvar uriConverter = {\n    convert: encodeURI,\n    revert: decodeURI\n};\nvar model = Bindings.defineBindings({}, {\n    \"title\": {\n        \"<->\": \"location\",\n        reverter: uriConverter\n    }\n});\n\nmodel.title = \"Hello, World!\";\nexpect(model.location).toEqual(\"Hello,%20World!\");\n\nmodel.location = \"Hello,%20Dave.\";\nexpect(model.title).toEqual(\"Hello, Dave.\");\n```\n\n### Computed Properties\n\nA computed property is one that gets updated with a function call when\none of its arguments changes.  Like a converter, it is useful in cases\nwhere a transformation or computation cannot be expressed in the\nproperty language, but can additionally accept multiple arguments as\ninput.  A computed property can be used as the source for another\nbinding.\n\nIn this example, we create an object as the root of multiple bindings.\nThe object synchronizes the properties of a \"form\" object with the\nwindow’s search string, effectively navigating to a new page whenever\nthe \"q\" or \"charset\" values of the form change.\n\n```javascript\nBindings.defineBindings({\n    window: window,\n    form: {\n        q: \"\",\n        charset: \"utf-8\"\n    }\n}, {\n    queryString: {\n        args: [\"form.q\", \"form.charset\"],\n        compute: function (q, charset) {\n            return \"?\" + QS.stringify({\n                q: q,\n                charset: charset\n            });\n        }\n    },\n    \"window.location.search\": {\n        \"<-\": \"queryString\"\n    }\n});\n```\n\n### Debugging with Traces\n\nA binding can be configured to log when it changes and why.  The `trace`\nproperty on a descriptor instructs the binder to log changes to the\nconsole.\n\n```javascript\nBindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<-\": \"a + 1\",\n    }\n});\n```\n\n\n## Reference\n\nFunctional Reactive Bindings is an implementation of synchronous,\nincremental object-property and collection-content bindings for\nJavaScript.  It was ripped from the heart of the [Montage][] web\napplication framework and beaten into this new, slightly magical form.\nIt must prove itself worthy before it can return.\n\n-   **functional**: The implementation uses functional building blocks\n    to compose observers and binders.\n-   **generic**: The implementation uses generic methods on collections,\n    like `addContentChangeListener`, so any object can implement the\n    same interface and be used in a binding.\n-   **reactive**: The values of properties and contents of collections\n    react to changes in the objects and collections on which they\n    depend.\n-   **synchronous**: All bindings are made consistent in the statement\n    that causes the change.  The alternative is asynchronous, where\n    changes are queued up and consistency is restored in a later event.\n-   **incremental**: If you update an array, it produces a content\n    change which contains the values you added, removed, and the\n    location of the change.  Most bindings can be updated using only\n    these values.  For example, a sum is updated by decreasing by the\n    sum of the values removed, and increasing by the sum of the values\n    added.  FRB can incrementally update `map`, `reversed`, `flatten`,\n    `sum`, and `average` observers.  It can also incrementally update\n    `has` bindings.\n-   **unwrapped**: Rather than wrap objects and arrays with observable\n    containers, FRB modifies existing arrays and objects to make them\n    dispatch property and content changes.  For objects, this involves\n    installing getters and setters using the ES5 `Object.defineProperty`\n    method.  For arrays, this involves replacing all of the mutation\n    methods, like `push` and `pop`, with variants that dispatch change\n    notifications.  The methods are either replaced by swapping the\n    `__proto__` or adding the methods to the instance with\n    `Object.defineProperties`.  These techniques should [work][Define\n    Property] starting in Internet Explorer 9, Firefox 4, Safari 5,\n    Chrome 7, and Opera 12.\n\n\n### Architecture\n\n-   [Collections][] provides **property, mapped content, and ranged\n    content change events** for objects, arrays, and other collections.\n    For objects, this adds a property descriptor to the observed object.\n    For arrays, this either swaps the prototype or mixes methods into\n    the array so that all methods dispatch change events.  \n    Caveats: you have to use a `set` method on Arrays to dispatch\n    property and content change events.  Does not work in older Internet\n    Explorers since they support neither prototype assignment or ES5\n    property setters.\n-   **observer** functions for watching an entire object graph for\n    incremental changes, and gracefully rearranging and canceling those\n    observers as the graph changes.  Observers can be constructed\n    directly or with a very small query language that compiles to a tree\n    of functions so no parsing occurs while the graph is being watched.\n-   one- and two-way **bindings** using binder and obserer functions to\n    incrementally update objects.\n-   **declarative** interface for creating an object graph with\n    bindings, properties, and computed properties with dependencies.\n\n\n### Bindings\n\nThe highest level interface for FRB resembles the ES5 Object constructor\nand can be used to declare objects and define and cancel bindings on\nthem with extended property descriptors.\n\n```javascript\nvar Bindings = require(\"frb\");\n\n// create an object\nvar object = Bindings.defineBindings({\n    foo: 0,\n    graph: [\n        {numbers: [1,2,3]},\n        {numbers: [4,5,6]}\n    ]\n}, {\n    bar: {\"<->\": \"foo\", enumerable: false},\n    numbers: {\"<-\": \"graph.map{numbers}.flatten()\"},\n    sum: {\"<-\": \"numbers.sum()\"},\n    reversed: {\"<-\": \"numbers.reversed()\"}\n});\n\nexpect(object.bar).toEqual(object.foo);\nobject.bar = 10;\nexpect(object.bar).toEqual(object.foo);\nexpect.foo = 20;\nexpect(object.bar).toEqual(object.foo);\n\n// note that the identity of the bound numbers array never\n// changes, because all of the changes to that array are\n// incrementally updated\nvar numbers = object.numbers;\n\n// first computation\nexpect(object.sum).toEqual(21);\n\n// adds an element to graph,\n// which pushes [7, 8, 9] to \"graph.map{numbers}\",\n// which splices [7, 8, 9] to the end of\n//  \"graph.map{numbers}.flatten()\",\n// which increments \"sum()\" by [7, 8, 9].sum()\nobject.graph.push({numbers: [7, 8, 9]});\nexpect(object.sum).toEqual(45);\n\n// splices [1] to the beginning of [1, 2, 3],\n// which splices [1] to the beginning of \"...flatten()\"\n// which increments \"sum()\" by [1].sum()\nobject.graph[0].numbers.unshift(1);\nexpect(object.sum).toEqual(46);\n\n// cancels the entire observer hierarchy, then attaches\n//  listeners to the new one.  updates the sum.\nobject.graph = [{numbers: [1,2,3]}];\nexpect(object.sum).toEqual(6);\n\nexpect(object.reversed).toEqual([3, 2, 1]);\n\nexpect(object.numbers).toBe(numbers) // still the same object\n\nBindings.cancelBindings(object); // cancels all bindings on this object and\n// their transitive observers and event listeners as deep as\n// they go\n```\n\n-   `Bindings.defineBindings(object, name, descriptor)`\n-   `Bindings.defineBinding(object, name, descriptor)`\n-   `Bindings.getBindings(object)`\n-   `Bindings.getBinding(object, name)`\n-   `Bindings.cancelBindings(object)`\n-   `Bindings.cancelBinding(object, name)`\n\nA binding descriptor contains:\n\n-   `target`: the\n-   `targetPath`: the target\n-   `targetSyntax`: the syntax tree for the target path\n-   `source`: the source object, which defaults to `target`\n-   `sourcePath`: the source path, from either ```<-``` or ```<->```\n-   `sourceSyntax`: the syntax tree for the source path\n-   `twoWay`: whether the binding goes in both directions, if ```<->```\n    was the source path.\n-   `parameters`: the parameters, which default to `source`.\n-   `convert`: a function that converts the source value to the target\n    value, useful for coercing strings to dates, for example.\n-   `revert`: a function that converts the target value to the source\n    value, useful for two-way bindings.\n-   `converter`: an object with `convert` and optionally also a `revert`\n    method.  The implementation binds these methods to their converter\n    and stores them in `covert` and `revert`.\n-   `serializable`: a note from the Montage Deserializer, to the [Montage\n    Serializer][], indicating that the binding came from a\n    serialization, and to a serialization it must return.\n-   `cancel`: a function to cancel the binding\n\n[Montage Serializer]: https://github.com/montagejs/mousse\n\n### Bind\n\nThe `bind` module provides direct access to the `bind` function.\n\n```javascript\nvar bind = require(\"frb/bind\");\n\nvar source = [{numbers: [1,2,3]}, {numbers: [4,5,6]}];\nvar target = {};\nvar cancel = bind(target, \"summary\", {\n    \"<-\": \"map{[numbers.sum(), numbers.average()]}\",\n    source: source\n});\n\nexpect(target.summary).toEqual([\n    [6, 2],\n    [15, 5]\n]);\n\ncancel();\n```\n\n`bind` is built on top of `parse`, `compileBinder`, and\n`compileObserver`.\n\n### Compute\n\nThe `compute` module provides direct access to the `compute` function,\nused by `Bindings` to make computed properties.\n\n```javascript\nvar compute = require(\"frb/compute\");\n\nvar source = {operands: [10, 20]};\nvar target = {};\nvar cancel = compute(target, \"sum\", {\n    source: source,\n    args: [\"operands.0\", \"operands.1\"],\n    compute: function (a, b) {\n        return a + b;\n    }\n});\n\nexpect(target.sum).toEqual(30);\n\n// change one operand\nsource.operands.set(1, 30); // needed to dispatch change notification\nexpect(target.sum).toEqual(40);\n```\n\n### Observe\n\nThe `observe` modules provides direct access to the `observe` function.\n`observe` is built on top of `parse` and `compileObserver`.\n`compileObserver` creates a tree of observers using the methods in the\n`observers` module.\n\n```javascript\nvar observe = require(\"frb/observe\");\n\nvar source = [1, 2, 3];\nvar sum;\nvar cancel = observe(source, \"sum()\", function (newSum) {\n    sum = newSum;\n});\n\nexpect(sum).toBe(6);\n\nsource.push(4);\nexpect(sum).toBe(10);\n\nsource.unshift(0); // no change\nexpect(sum).toBe(10);\n\ncancel();\nsource.splice(0, source.length); // would change\nexpect(sum).toBe(10);\n```\n\n`observe` produces a cancelation hierarchy.  Each time a value is\nremoved from an array, the underlying observers are canceled.  Each time\na property is replaced, the underlying observer is canceled.  When new\nvalues are added or replaced, the observer produces a new canceler.  The\ncancel function returned by `observe` commands the entire underlying\ntree.\n\nObservers also optional accept a descriptor argument in place of a\ncallback.\n\n-   `set`: the change handler, receives `value` for most observers, but\n    also `key` and `object` for property changes.\n-   `parameters`: the value for `$` expressions.\n-   `beforeChange`: instructs an observer to emit the previous value\n    before a change occurs.\n-   `contentChange`: instructs an observer to emit an array every time\n    its content changes.  By default, arrays are only emitted once.\n\n```javascript\nvar object = {};\nvar cancel = observe(object, \"array\", {\n    change: function (value) {\n        // may return a cancel function for a nested observer\n    },\n    parameters: {},\n    beforeChange: false,\n    contentChange: true\n});\n\nobject.array = []; // emits []\nobject.array.push(10); // emits [10]\n```\n\n### Evaluate\n\nThe `compile-evaluator` module returns a function that accepts a syntax\ntree and returns an evaluator function.  The evaluator accepts a scope\n(which may include a value, parent scope, parameters, a document, and\ncomponents) and returns the corresponding value without all the cost or\nbenefit of setting up incremental observers.\n\n```javascript\nvar parse = require(\"frb/parse\");\nvar compile = require(\"frb/compile-evaluator\");\nvar Scope = require(\"frb/scope\");\n\nvar syntax = parse(\"a.b\");\nvar evaluate = compile(syntax);\nvar c = evaluate(new Scope({a: {b: 10}}))\nexpect(c).toBe(10);\n```\n\nThe `evaluate` module returns a function that accepts a path or syntax\ntree, a source value, and parameters and returns the corresponding\nvalue.\n\n```javascript\nvar evaluate = require(\"frb/evaluate\");\nvar c = evaluate(\"a.b\", {a: {b: 10}})\nexpect(c).toBe(10);\n```\n\n\n### Stringify\n\nThe `stringify` module returns a function that accepts a syntax tree and\nreturns the corresponding path in normal form.\n\n```javascript\nvar stringify = require(\"frb/stringify\");\n\nvar syntax = {type: \"and\", args: [\n    {type: \"property\", args: [\n        {type: \"value\"},\n        {type: \"literal\", value: \"a\"}\n    ]},\n    {type: \"property\", args: [\n        {type: \"value\"},\n        {type: \"literal\", value: \"b\"}\n    ]}\n]};\n\nvar path = stringify(syntax);\nexpect(path).toBe(\"a && b\");\n```\n\n\n### Grammar\n\n-   **expression** = **logical-or-expression**\n-   **conditional-expression** = **logical-or-expression** ( `?`\n    **expression** `:` **expression** )?\n-   **logical-or-expression** = **logical-and-expression** ( `||` *(or)*\n    **relation expression** )?\n-   **logical-and-expression** = **relation-expression** ( `&&` *(and)*\n    **relation-expression** )?\n-   **relation-expression** = **arithmetic expression** (\n    **relation-operator** **arithmetic-expression** )?\n    -   **relation-operator** = `==` *(equals)* or ```<``` *(lt)* or\n        ```<=``` *(le)* or ```>``` *(gt)* or ```>=``` *(ge)* or\n        ```<=>``` *(compare)*\n-   **arithmetic-expression** = **multiplicative-expresion** delimited by **arithmetic-operator**\n    -   **arithmetic-operator** = `+` *(add)* or `-` *(sub)*\n-   **multiplicative-expression** = **exponential-expression**\n    delimited by **multiplicative-operator**\n    -   **multiplicative-operator** = `*` *(mul)* or `/` *(div)* or\n        `%` *(mod)* or `rem` *(rem)*\n-   **exponential-expression** = **unary-expression** delimited by\n    **exponential-operator**\n    -   **exponential-operator** = `**` *(pow)* or `//` *(root)* or\n        `%%` *(log)*\n-   **unary-expression** = **unary-operator** ? **path-expression**\n    -   **unary-operator** = `+` *(number)* or `-` *(neg)* or `!` *(not)*\n-   **path-expression** =\n    -   **literal** *(literal with value)* or\n    -   **array-expression** *(tuple)* or\n    -   **object-expression** *(record)* or\n    -   `(` **expression** `)` **tail-expression** or\n    -   **property-name** **tail-expression** *(property)* or\n    -   **function-call** *(piped)* **tail-expression** or\n    -   **block-call** **tail-expression** or\n    -   `#` **element-id** **tail-expression** *(element by id)* or\n    -   `@` **component-label** **tail-expression** *(component by label)*\n    -   `&` **function-call** *(bare)* **tail-expression** or\n-   **tail-expression** =\n    -   **property-expression** or\n    -   **with-expression** or\n    -   **variable-property-expression**\n-   **property-expression** = `.` **property-name** **tail-expression**\n    *(property)*\n-   **with-expression** = `.`\n    -   `(` **expression** `)` **tail-expression** or\n    -   **array-expression** **tail-expression** or\n    -   **object-expression** **tail-expression**\n-   **variable-property-expression** = `[` **expression** `]`\n    **tail-expression** *(property)*\n-   **array-expression** = `[` ( **expression** or `()` *(value)* )\n    delimited by `,` `]` *(tuple with each expression in args array)*\n-   **object-expression** = `{` (**property-name** `:` **expression**)\n    delimited by `,` `}` *(record, with each expression as a value in an\n    args object instead of array)*\n-   **property-name** = ( **non-space-character** )+\n-   **function-call** = **function-name** `(` **expression** delimited\n    by `,` `)`\n    -   **function-name** = `flatten` or `reversed` or `enumerate` or\n        `sum` or `average` or `has` or `view` or `startsWith` or\n        `endsWith` or `contains` or `join` or `split` or `range` or\n        `keys` or `values` or `entries` *(eponymous syntax node types)*\n-   **block-call** = **function-name** `{` **expression** `}`\n    -   **block-name** = `map` *(mapBlock)* or `filter` *(filterBlock)*\n        or `some` *(someBlock)* or `every` *(everyBlock)* or `sorted`\n        *(sortedBlock)* or `min` *(minBlock)* or `max` *(maxBlock)* or\n        `group` *(groupBlock)* or `groupMap` *(groupMapBlock)* or\n        **function-name** *(map followed by function-call)*\n-   **literal** = **string-literal** or **number-literal**\n    -   **number-literal** = **digits** ( `.` **digits** )? *(literal\n        and value is a number)*\n    -   **string-literal** = `'` ( **non-quote-character** or `\\`\n        **character** ) `'` *(literal and value is a string)*\n\nLegend:\n\n-   **terms-of-the-grammar**\n-   `tokens`\n-   *(corresponding syntax node type name)*\n-   (group)\n-   definition =\n-   or\n-   delimited by\n-   optional?\n-   any*\n-   some+\n\n### Semantics\n\nAn expression is observed with a source value and emits a target\none or more times.  All expressions emit an initial value.  Array\ntargets are always updated incrementally.  Numbers and boolean are\nemited anew each time their value changes.\n\nIf any operand is `null` or `undefine`, a binding will not emit an\nupdate.  Thus, if a binding’s source becomes invalid, it does not\ncorrupt its target but waits until a valid replacement becomes\navailable.\n\n-   Literals are interpreted as their corresponding value.\n-   Value terms provide the source.\n-   Parameters terms provide the parameters.\n-   In a path-expression, the first term is evaluated with the source\n    value.\n-   Each subsequent term of a path expression uses the target of the\n    previous as its source.\n-   A property-expression or variable-property-expression observes the\n    key of the source object using `Object.addPropertyChangeListener`.\n-   An element identifier (with the `#` prefix) uses the `document`\n    property of the `parameters` object and emits\n    `document.getElementById(id)`, or dies trying.  Changes to the\n    document are not observed.\n-   A component label (with the `@` prefix) uses the `serialization`\n    property of `parameters` object and emits\n    `serialization.getObjectForLable(label)`, or dies trying.  Changes\n    to the serialization are not observed.  This syntax exists to\n    support [Montage][] serializations.\n-   A \"map\" block observes the source array and emits a target array.\n    The target array is emitted once and all subsequent updates are\n    reflected as content changes that can be independently observed with\n    `addContentChangeListener`.  Each element of the target array\n    corresponds to the observed value of the block expression using the\n    respective element in the source array as the source value.\n-   A \"map\" function call receives a function as its argument rather\n    than a block.\n-   A \"filter\" block observes the source array and emits a target array\n    containing only those values from the source array that actively\n    pass the predicate described in the block expression useing the\n    respective element in the source array as the source value.  As with\n    \"map\", filters update the target array incrementally.\n-   A \"some\" block observes whether any of the values in the source\n    collection meet the given criterion.\n-   A \"every\" block observes whether all of the values in the source\n    collection meet the given criterion.\n-   A \"sorted\" block observes the sorted version of an array, by a\n    property of each value described in the block, or itself if empty.\n    Sorted arrays are incrementally updating as values are added and\n    deleted from the source.\n-   A \"min\" block observes the which of the values in a given collection\n    produces the smallest value through the given relation.\n-   A \"max\" block observes the which of the values in a given collection\n    produces the largest value through the given relation.\n-   A \"group\" block observes which values belong to corresponding\n    equivalence classes as determined by the result of a given\n    expression on each value.  The observer is responsible for adding\n    and removing classes as they are populated and depopulated.  Each\n    class tracks the key (result of the block expression for every\n    member of a class), and an the values of the corresponding class as\n    an array.  Values are added to the end of each array as they are\n    discovered.\n-   Any function call with a \"block\" implies calling the function on the\n    result of a \"map\" block.\n-   A \"flatten\" function call observes a source array and produces a\n    target array.  The source array must only contain inner arrays.  The\n    target array is emitted once and all subsequent updates can be\n    independently observed with `addContentChangeListener`.  The target\n    array will always contain the concatenation of all of the source\n    arrays.  Changes to the inner and outer source arrays are reflected\n    with incremental splices to the target array in their corresponding\n    positions.\n-   A \"reversed\" function call observes the source array and produces a\n    target array that contains the elements of the source array in\n    reverse order.  The target is incrementally updated.\n-   An \"enumerate\" expression observes [key, value] pairs from an array.\n    The output array of arrays is incrementally updated with range\n    changes from the source.\n-   A \"view\" function call observes a sliding window from the source,\n    from a start index (first argument) of a certain length (second\n    argument).  The source can be any collection that dispatches range\n    changes and the output will be an array of the given length.\n-   A \"sum\" function call observes the numeric sum of the source array.\n    Each alteration to the source array causes a new sum to be emitted,\n    but the sum is computed incrementally by observing the smaller sums\n    of the spliced values, added and removed.\n-   An \"average\" function call observes the average of the input values,\n    much like \"sum\".\n-   A \"has\" function call observes the source collection for whether it\n    contains an observed value.\n-   A \"tuple\" expression observes a source value and emits a single\n    target array with elements corresponding to the respective\n    expression in the tuple.  Each inner expression is evaluated with\n    the same source value as the outer expression.\n-   A \"startsWith\" function call observes whether the left string\n    starts with the right string.\n-   An \"endsWith\" function call observes whether the right string\n    ends with the right string.\n-   A \"contains\" function call observes whether the left string contains\n    the right string.\n-   A \"join\" function observes the left array joined by the right\n    delimiter, or an empty string.   This is not an incremental\n    operation.\n-   A \"split\" function observes the left string broken into an array\n    between the right delimiter, or an empty string.  This is not an\n    incremental operation.\n-   A \"range\" function call observes an array with the given length\n    containing sequential numbers starting with zero.  The output array\n    is updated incrementally and will dispatch one range change each\n    time the size changes by any difference.\n-   A \"keys\" function call observes an incrementally updated array of\n    the keys that a given map contains.  The keys are maintained in\n    insertion order.\n-   A \"values\" function call observes an incrementally updated array of\n    the values that a given map contains.  The values are maintained in\n    insertion order.\n-   An \"entries\" function call observes an incrementally updated array\n    of [key, value] pairs from a given mapping.  The entries are\n    retained in insertion order.\n\nUnary operators:\n\n-   \"number\" coerces the value to a number.\n-   \"neg\" converts a number to its negative.\n-   \"not\" converts a boolean to its logical opposite.\n\nBinary operators:\n\n-   \"add\" adds the left to the right\n-   \"sub\" subtracts the right from the left\n-   \"mul\" multiples the left to the right\n-   \"div\" divides the left by the right\n-   \"mod\" produces the left modula the right.  This is proper modula,\n    meaning a negative number that does not divide evenly into a\n    positive number will produce the difference between that number and\n    the next evenly divisible number in direction of negative infinity.\n-   \"rem\" produces the remainder of dividing the left by the right.  If\n    the left does not divide evenly into the right it will produce the\n    difference between that number and the next evenly divisible number\n    in the direction of zero.  That is to say, `rem` can produce\n    negative numbers.\n-   \"pow\" raises the left to the power of the right.\n-   \"root\" produces the \"righth\" root of the left.\n-   \"log\" produces the logarithm of the left on the right base.\n-   \"lt\" less than, as determined with `Object.compare(left, right) <\n    0`.\n-   \"le\" less than or equal, as determined with `Object.compare(left,\n    right) <= 0`.\n-   \"gt\" greater than, as determined with `Object.compare(left, right) >\n    0`.\n-   \"ge\" greater than or equal, as determined with `Object.compare(left,\n    right) >= 0`.\n-   \"compare\" as determined by `Object.compare(left, right)`.\n-   \"equals\" whether the left is equal to the right as determined by\n    `Object.equals(left, right)`.\n-   *Note: there is no \"not equals\" syntax node. The `!=` operator gets\n    converted into a \"not\" node around an \"equals\" node.\n-   \"and\" logical union\n-   \"or\" logical intersection\n\nTernary operator:\n\n-   \"if\" observes the condition (first argument, expression before the\n    `?`).  If the expression is true, the result observes the consequent\n    expression (second argument, between the question mark and the\n    colon), and if it is false, the result observes the alternate (the\n    third argument, after the colon).  If the condition is null or\n    undefined, the result is null or undefined.\n\nOn the left hand side of a binding, the last term has alternate\nsemantics.  Binders receive a target as well as a source.\n\n-   A \"property\" observes an object and a property name from the target,\n    and a value from the source.  When any of these change, the binder\n    upates the value for the property name of the object.\n-   A \"get\" observes a collection and a key from the target, and a value\n    from the source.  When any of these change, the binder updates the\n    value for the key on the collection using `collection.set(key,\n    value)`.  This is suitable for arrays and custom map\n    [Collections][].\n-   A \"equals\" expression observes a boolean value from the source.  If\n    that boolean becomes true, the equality expression is made true by\n    assigning the right expression to the left property of the equality,\n    turning the \"equals\" into an \"assign\" conceptually.  No action is\n    taken if the boolean becomes false.\n-   A \"reversed\" expression observes an indexed collection and maintains\n    a mirror array of that collection.\n-   A \"has\" function call observes a boolean value from the source, and\n    an collection and a sought value from the target.  When the value is\n    true and the value is absent in the collection, the binder uses the\n    `add` method of the collection (provided by a shim for arrays) to\n    make it true that the collection contains the sought value.  When\n    the value is false and the value does appear in the collection one\n    or more times, the binder uses the `delete` or `remove` method of\n    the collection to remove all occurrences of the sought value.\n-   An \"if\" binding observes the condition and binds the target either\n    to the consequent or alternate.  If the condition is null or\n    undefined, the target is not bound.\n\nIf the target expression ends with `.*`, the content of the target is\nbound instead of the property.  This is useful for binding the content\nof a non-array collection to the content of another indexed collection.\nThe collection can be any collection that implements the \"observable\ncontent\" interface including `dispatchContentChange(plus, minus,\nindex)`, `addContentChangeListener`, and `removeContentChangeListener`.\n\n### Language Interface\n\n```javascript\nvar parse = require(\"frb/parse\");\nvar compileObserver = require(\"frb/compile-observer\");\nvar compileBinder = require(\"frb/compile-binder\");\n```\n\n-   `parse(text)` returns a syntax tree.\n-   `compileObserver(syntax)` returns an observer function of the form\n    `observe(callback, source, parameters)` which in turn returns a\n    `cancel()` function.  `compileObserver` visits the syntax tree and\n    creates functions for each node, using the `observers` module.\n-   `compileBinder(syntax)` returns a binder function of the form\n    `bind(observeValue, source, target, parameters)` which in turn\n    returns a `cancel()` function.  `compileBinder` visits the root node\n    of the syntax tree and delegates to `compileObserver` for its terms.\n    The root node must be a `property` at this time, but could\n    conceivably be any function with a clear inverse operation like\n    `map` and `reversed`.\n\n### Syntax Tree\n\nThe syntax tree is JSON serializable and has a \"type\" property.  Nodes\nhave the following types:\n\n-   `value` corresponds to observing the source value\n-   `parameters` corresponds to observing the parameters object\n-   `literal` has a `value` property and observes that value\n-   `element` has an `id` property and observes an element from the\n    `parameters.document`, by way of `getElementById`.\n-   `component` has a `label` property and observes a component from the\n    `parameters.serialization`, by way of `getObjectForLabel`.  This\n    feature support's [Montage][]’s serialization format.\n\nAll other node types have an \"args\" property that is an array of syntax\nnodes (or an \"args\" object for `record`).\n\n-   `property`: corresponds to observing a property named by the right\n    argument of the left argument.\n-   `get`: corresponds to observing the value for a key (second\n    argument) in a collection (first argument).\n-   `with`: corresponds to observing the right expression using the left\n    expression as the source.\n-   `has`: corresponds to whether the key (second argument) exists\n    within a collection (first argument)\n-   `mapBlock`: the left is the input, the right is an expression to\n    observe on each element of the input.\n-   `filterBlock`: the left is the input, the right is an expression to\n    determine whether the result is included in the output.\n-   `someBlock`: the left is the input, the right is a criterion.\n-   `everyBlock`: the left is the input, the right is a criterion.\n-   `sortedBlock`: the left is the input, the right is a relation on\n    each value of the input on which to compare to determine the order.\n-   `minBlock`: the left is the input, the right is a relation on each\n    value of the input by which to compare the value to others.\n-   `maxBlock`: the left is the input, the right is a relation on each\n    value of the input by which to compare the value to others.\n-   `groupBlock`: the left is the input, the right is an expression that\n    provides the key for an equivalence class for each value in the\n    input.  The output is an array of entries, `[key, class]`, with the\n    shared key of every value in the equivalence class.\n-   `groupMapBlock`: has the same input semantics as `groupBlock`, but\n    the output is a `Map` instance instead of an array of entries.\n-   `tuple`: has any number of arguments, each an expression to observe\n    in terms of the source value.\n-   `record`: as an args object. The keys are property names for the\n    resulting object, and the values are the corresponding syntax nodes\n    for the values.\n-   `view`: the arguments are the input, the start position, and the\n    length of the sliding window to view from the input.  The input may\n    correspond to any ranged content collection, like an array or sorted\n    set.\n-   `rangeContent`: corresponds to the content of an ordered collection\n    that can dispatch indexed range changes like an array or sorted set.\n    This indicates to a binder that it should replace the content of the\n    target instead of replacing the target property with the observed\n    content of the source.  A range content node has no effect on the\n    source.\n-   `mapContent`: corresponds to the content of a map-like collection\n    including arrays and all map [Collections][].  These collections\n    dispatch map changes, which create, read, update, or delete\n    key-to-value pairs.  This indicates to a binder to replace the\n    content of the target map-like collection with the observed content\n    of the source, instead of replacing the target collection.  A map\n    change node on the source side just passes the collection forward\n    without alteration.\n\nFor all operators, the \"args\" property are operands.  The node types for\nunary operators are:\n\n-   ```+```: `number`, arithmetic coercion\n-   ```-```: `neg`, arithmetic negation\n-   ```!```: `not`, logical negation\n\nFor all binary operators, the node types are:\n\n-   ```**```: `pow`, exponential power\n-   ```//```: `root`, of 2 square root, of 3 cube root, etc\n-   ```%%```: `log`, logarithm with base\n-   ```*```: `mul`, multiplication\n-   ```/```: `div`, division\n-   ```%```: `mod`, modulo (toward negative infinity, always positive)\n-   ```rem```: `rem`, remainder (toward zero, negative if negative)\n-   ```+```: `add`, addition\n-   ```-```: `sub`, subtraction\n-   ```<```: `lt`, less than\n-   ```<=```: `le`, less than or equal\n-   ```>```: `gt`, greater than\n-   ```>=```: `ge`, greater than or equal\n-   ```<=>```: `compare`\n-   ```==```: ``equals``, equality comparison and assignment\n-   ```!=``` produces unary negation and equality comparison or\n    assignment so does not have a corresponding node type.  The\n    simplification makes it easier to rotate the syntax tree\n    algebraically.\n-   ```&&```, `and`, logical and\n-   ```||```, `or`, logical or\n\nFor the ternary operator:\n\n-   ```?``` and ```:```: `if`, ternary conditional\n\nFor all function calls, the right hand side is a tuple of arguments.\n\n-   `reversed`\n-   `enumerate`\n-   `flatten`\n-   `sum`\n-   `average`\n-   `startsWith`\n-   `endsWith`\n-   `contains`\n-   `join`\n-   `split`\n-   `range`\n-   `keys`\n-   `values`\n-   `entries`\n\n\n### Observers and Binders\n\nThe `observers` module contains functions for making all of the\ndifferent types of observers, and utilities for creating new ones.\nAll of these functions are or return an observer function of the form\n`observe(emit, value, parameters)` which in turn returns `cancel()`.\n\n-   `observeValue`\n-   `observeParameters`\n-   `makeLiteralObserver(value)`\n-   `makeElementObserver(id)`\n-   `makeComponentObserver(label)`\n-   `makeRelationObserver(callback, thisp)` is unavailable through the\n    property binding language, translates a value through a JavaScript\n    function.\n-   `makeComputerObserver(observeArgs, compute, thisp)` applies\n    arguments to the computation function to get a new value.\n-   `makeConverterObserver(observeValue, convert, thisp)` calls the\n    converter function to transform a value to a converted value.\n-   `makePropertyObserver(observeObject, observeKey)`\n-   `makeGetObserver(observeCollection, observeKey)`\n-   `makeMapFunctionObserver(observeArray, observeFunction)`\n-   `makeMapBlockObserver(observeArray, observeRelation)`\n-   `makeFilterBlockObserver(observeArray, observePredicate)`\n-   `makeSortedBlockObserver(observeArray, observeRelation)`\n-   `makeEnumerationObserver(observeArray)`\n-   `makeFlattenObserver(observeOuterArray)`\n-   `makeTupleObserver(...observers)`\n-   `makeObserversObserver(observers)`\n-   `makeReversedObserver(observeArrayh)`\n-   `makeWindowObserver` is not presently available through the language\n    and is subject to change.  It is for watching a length from an array\n    starting at an observable index.\n-   `makeSumObserver(observeArray)`\n-   `makeAverageObserver(observeArray)`\n-   `makeParentObserver(observeExpression)`\n-   *etc*\n\nThese are utilities for making observer functions.\n\n-   `makeNonReplacing(observe)` accepts an array observer (the emitted\n    values must be arrays) and returns an array observer that will only\n    emit the target once and then incrementally update that target.  All\n    array observers use this decorator to handle the case where the\n    source value gets replaced.\n-   `makeArrayObserverMaker(setup)` generates an observer that uses an\n    array as its source and then incrementally updates a target value,\n    like `sum` and `average`.  The `setup(source, emit)` function must\n    return an object of the form `{contentChange, cancel}` and arrange\n    for `emit` to be called with new values when `contentChange(plus,\n    minus, index)` receives incremental updates.\n-   `makeUniq(callback)` wraps an emitter callback such that it only\n    forwards new values.  So, if a value is repeated, subsequent calls\n    are ignored.\n-   `autoCancelPrevious(callback)` accepts an observer callback and\n    returns an observer callback.  Observer callbacks may return\n    cancelation functions, so this decorator arranges for the previous\n    canceler to be called before producing a new one, and arranges for\n    the last canceler to be called when the whole tree is done.\n-   `once(callback)` accepts a canceler function and ensures that the\n    cancelation routine is only called once.\n\nThe `binders` module contains similar functions for binding an observed\nvalue to a bound value.  All binders are of the form `bind(observeValue,\nsource, target, parameters)` and return a `cancel()` function.\n\n-   `makePropertyBinder(observeObject, observeKey)`\n-   `makeGetBinder(observeCollection, observeKey)`\n-   `makeHasBinder(observeCollection, observeValue)`\n-   `makeEqualityBinder(observeLeft, observeRight)`\n-   `makeRangeContentBinder(observeTarget)`\n-   `makeMapContentBinder(observeTarget)`\n-   `makeReversedBinder(observeTarget)`\n\n\n[Collections]: https://github.com/kriskowal/collections\n[Define Property]: http://kangax.github.com/es5-compat-table/#define-property-webkit-note\n[Montage]: https://github.com/montagejs/montage\n[Mr]: https://github.com/kriskowal/mr\n[Mutation Observers]: https://developer.mozilla.org/en-US/docs/DOM/DOM_Mutation_Observers\n[Node.js]: http://nodejs.org/\n\n","readmeFilename":"README.md","_id":"frb@0.2.11","_from":"frb@~0.2.3","directories":{"lib":"./"},"hash":"3ed547c","mappings":{"collections":{"name":"collections","hash":"5fa10d2","location":"../collections@5fa10d2/"}},"production":true,"useScriptInjection":true}