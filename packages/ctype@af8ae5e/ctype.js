function ctReadUint8(e,t,n){var r=mod_ctio.ruint8(t,e,n);return{value:r,size:1}}function ctReadUint16(e,t,n){var r=mod_ctio.ruint16(t,e,n);return{value:r,size:2}}function ctReadUint32(e,t,n){var r=mod_ctio.ruint32(t,e,n);return{value:r,size:4}}function ctReadUint64(e,t,n){var r=mod_ctio.ruint64(t,e,n);return{value:r,size:8}}function ctReadSint8(e,t,n){var r=mod_ctio.rsint8(t,e,n);return{value:r,size:1}}function ctReadSint16(e,t,n){var r=mod_ctio.rsint16(t,e,n);return{value:r,size:2}}function ctReadSint32(e,t,n){var r=mod_ctio.rsint32(t,e,n);return{value:r,size:4}}function ctReadSint64(e,t,n){var r=mod_ctio.rsint64(t,e,n);return{value:r,size:8}}function ctReadFloat(e,t,n){var r=mod_ctio.rfloat(t,e,n);return{value:r,size:4}}function ctReadDouble(e,t,n){var r=mod_ctio.rdouble(t,e,n);return{value:r,size:8}}function ctReadChar(e,t,n){var r=new Buffer(1);return r[0]=mod_ctio.ruint8(t,e,n),{value:r,size:1}}function ctReadCharArray(e,t,n,r){var i,s=new Buffer(e);for(i=0;i<e;i++)s[i]=mod_ctio.ruint8(n,t,r+i);return{value:s,size:e}}function ctWriteUint8(e,t,n,r){return mod_ctio.wuint8(e,t,n,r),1}function ctWriteUint16(e,t,n,r){return mod_ctio.wuint16(e,t,n,r),2}function ctWriteUint32(e,t,n,r){return mod_ctio.wuint32(e,t,n,r),4}function ctWriteUint64(e,t,n,r){return mod_ctio.wuint64(e,t,n,r),8}function ctWriteSint8(e,t,n,r){return mod_ctio.wsint8(e,t,n,r),1}function ctWriteSint16(e,t,n,r){return mod_ctio.wsint16(e,t,n,r),2}function ctWriteSint32(e,t,n,r){return mod_ctio.wsint32(e,t,n,r),4}function ctWriteSint64(e,t,n,r){return mod_ctio.wsint64(e,t,n,r),8}function ctWriteFloat(e,t,n,r){return mod_ctio.wfloat(e,t,n,r),4}function ctWriteDouble(e,t,n,r){return mod_ctio.wdouble(e,t,n,r),8}function ctWriteChar(e,t,n,r){if(e instanceof Buffer)return mod_ctio.ruint8(e[0],t,n,r),1;throw new Error("Input must be a buffer")}function ctWriteCharArray(e,t,n,r,i){var s;if(e instanceof Buffer){if(e.length>t)throw new Error("value length greater than array length");for(s=0;s<e.length&&s<t;s++)mod_ctio.wuint8(e[s],n,r,i+s);for(;s<t;s++)mod_ctio.wuint8(0,n,i+s);return t}throw new Error("Input must be a buffer")}function ctGetBasicTypes(){var e={},t;for(t in deftypes)e[t]=deftypes[t];return e}function ctParseType(e){var t,n,r,i;if(typeof e!="string")throw new Error("type must be a Javascript string");n=e.lastIndexOf("]");if(n==-1){if(e.lastIndexOf("[")!=-1)throw new Error("found invalid type with '[' but no corresponding ']'");return{type:e}}t=e.lastIndexOf("[");if(t==-1)throw new Error("found invalid type with ']' but no corresponding '['");if(t>=n)throw new Error("malformed type, ']' appears before '['");return r=e.substring(0,t),i=e.substring(t+1,n),{type:r,len:i}}function ctCheckReq(e,t,n){var r,i,s,o,u,a={};if(!(e instanceof Array))throw new Error("definition is not an array");if(e.length===0)throw new Error("definition must have at least one element");for(r=0;r<e.length;r++){s=e[r];if(!(s instanceof Object))throw new Error("definition must be an array ofobjects");o=Object.keys(s);if(o.length!=1)throw new Error("definition entry must only have one key");if(o[0]in a)throw new Error("Specified name already specified: "+o[0]);if(!("type"in s[o[0]]))throw new Error("missing required type definition");u=ctParseType(s[o[0]].type);while(u.len!==undefined){if(!(!isNaN(parseInt(u.len,10))||u.len in a))throw new Error("Given an array length without a matching type");u=ctParseType(u.type)}if(!(u.type in t))throw new Error("type not found or typdefed: "+u.type);if(n!==undefined)for(i=0;i<n.length;i++)if(!(n[i]in s[o[0]]))throw new Error("Missing required field: "+n[i]);a[o[0]]=!0}}function CTypeParser(e){if(!e)throw new Error("missing required argument");if(!("endian"in e))throw new Error("missing required endian value");if(e["endian"]!="big"&&e["endian"]!="little")throw new Error("Invalid endian type");if("char-type"in e&&e["char-type"]!="uint8"&&e["char-type"]!="int8")throw new Error("invalid option for char-type: "+e["char-type"]);this.endian=e.endian,this.types=ctGetBasicTypes(),"char-type"in e&&e["char-type"]=="uint8"&&(this.types["char"]=this.types.uint8_t),"char-type"in e&&e["char-type"]=="int8"&&(this.types["char"]=this.types.int8_t)}function ctResolveArray(e,t){var n="",r=ctParseType(e);while(r.len!==undefined){if(isNaN(parseInt(r.len,10))){if(typeof t[r["len"]]!="number")throw new Error("cannot sawp in non-number for array value");n="["+t[r.len]+"]"+n}else n="["+r.len+"]"+n;r=ctParseType(r.type)}return n=r.type+n,n}function getValues(e){var t,n,r;n=[];for(t=0;t<e.length;t++)r=Object.keys(e[t])[0],mod_assert.ok("value"in e[t][r]),n.push(e[t][r].value);return n}function toAbs64(e){if(e===undefined)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(e.length!=2)throw new Error("value must be an array of length 2");if(e[0]>=1048576)throw new Error("value would become approximated");return e[0]*Math.pow(2,32)+e[1]}function toApprox64(e){if(e===undefined)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(e.length!=2)throw new Error("value must be an array of length 2");return Math.pow(2,32)*e[0]+e[1]}function parseCTF(e,t){var n=new CTypeParser(t);return mod_ctf.ctfParseJson(e,n),n}var mod_ctf=require("./ctf.js"),mod_ctio=require("./ctio.js"),mod_assert=require("assert"),deftypes={uint8_t:{read:ctReadUint8,write:ctWriteUint8},uint16_t:{read:ctReadUint16,write:ctWriteUint16},uint32_t:{read:ctReadUint32,write:ctWriteUint32},uint64_t:{read:ctReadUint64,write:ctWriteUint64},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},int64_t:{read:ctReadSint64,write:ctWriteSint64},"float":{read:ctReadFloat,write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};CTypeParser.prototype.setEndian=function(e){if(e!="big"&&e!="little")throw new Error("invalid endian type, must be big or little");this.endian=e},CTypeParser.prototype.getEndian=function(){return this.endian},CTypeParser.prototype.typedef=function(e,t){var n;if(e===undefined)throw new(Error("missing required typedef argument: name"));if(t===undefined)throw new(Error("missing required typedef argument: value"));if(typeof e!="string")throw new(Error("the name of a type must be a string"));n=ctParseType(e);if(n.len!==undefined)throw new Error("Cannot have an array in the typedef name");if(e in this.types)throw new Error("typedef name already present: "+e);if(!(typeof t=="string"||t instanceof Array))throw new Error("typedef value must either be a string or struct");if(typeof t=="string"){n=ctParseType(t);if(n.len!==undefined&&isNaN(parseInt(n.len,10)))throw new(Error("typedef value must use fixed size array when outside of a struct"));this.types[e]=t}else ctCheckReq(t,this.types),this.types[e]=t},CTypeParser.prototype.lstypes=function(){var e,t={};for(e in this.types){if(e in deftypes)continue;t[e]=this.types[e]}return t},CTypeParser.prototype.resolveTypedef=function(e,t,n,r,i){var s;mod_assert.ok(e in this.types);if(typeof this.types[e]=="string"){s=ctParseType(this.types[e]);if(t=="read")return this.readEntry(s,n,r);if(t=="write")return this.writeEntry(i,s,n,r);throw new Error("invalid dispatch type to resolveTypedef")}if(t=="read")return this.readStruct(this.types[e],n,r);if(t=="write")return this.writeStruct(i,this.types[e],n,r);throw new Error("invalid dispatch type to resolveTypedef")},CTypeParser.prototype.readEntry=function(e,t,n){var r,i;if(e.len!==undefined){i=parseInt(e.len,10);if(isNaN(i))throw new Error("somehow got a non-numeric length");e["type"]=="char"?r=this.types["char[]"].read(i,this.endian,t,n):r=this.readArray(e.type,i,t,n)}else e.type in deftypes?r=this.types[e.type].read(this.endian,t,n):r=this.resolveTypedef(e.type,"read",t,n);return r},CTypeParser.prototype.readArray=function(e,t,n,r){var i,s,o,u=r,a=new Array(t);o=ctParseType(e);for(i=0;i<t;i++)s=this.readEntry(o,n,r),r+=s.size,a[i]=s.value;return{value:a,size:r-u}},CTypeParser.prototype.readStruct=function(e,t,n){var r,i,s,o,u,a=n,f={};for(i=0;i<e.length;i++)u=Object.keys(e[i])[0],o=e[i][u],s=ctParseType(ctResolveArray(o.type,f)),"offset"in o&&(n=a+o.offset),r=this.readEntry(s,t,n),n+=r.size,f[u]=r.value;return{value:f,size:n-a}},CTypeParser.prototype.readData=function(e,t,n){if(e===undefined)throw new Error("missing definition for what we should beparsing");if(t===undefined)throw new Error("missing buffer for what we should be parsing");if(n===undefined)throw new Error("missing offset for what we should be parsing");return ctCheckReq(e,this.types),this.readStruct(e,t,n).value},CTypeParser.prototype.writeArray=function(e,t,n,r,i){var s,o,u=i;if(e instanceof Array){if(e.length!=n)throw new Error("asked to write array of length "+n+" but that does not match value length: "+e.length);o=ctParseType(t);for(s=0;s<n;s++)i+=this.writeEntry(e[s],o,r,i);return i-u}throw new Error("asked to write an array, but value is not an array")},CTypeParser.prototype.writeEntry=function(e,t,n,r){var i,s;if(t.len!==undefined){i=parseInt(t.len,10);if(isNaN(i))throw new Error("somehow got a non-numeric length");t["type"]=="char"?s=this.types["char[]"].write(e,i,this.endian,n,r):s=this.writeArray(e,t.type,i,n,r)}else t.type in deftypes?s=this.types[t.type].write(e,this.endian,n,r):s=this.resolveTypedef(t.type,"write",n,r,e);return s},CTypeParser.prototype.writeStruct=function(e,t,n,r){var i,s,o,u,a=r,f={};for(i=0;i<t.length;i++)u=Object.keys(t[i])[0],s=t[i][u],o=ctParseType(ctResolveArray(s.type,f)),"offset"in s&&(r=a+s.offset),r+=this.writeEntry(e[i],o,n,r),f[u]=e[i];return r},CTypeParser.prototype.writeData=function(e,t,n,r){var i;if(e===undefined)throw new Error("missing definition for what we should beparsing");if(t===undefined)throw new Error("missing buffer for what we should be parsing");if(n===undefined)throw new Error("missing offset for what we should be parsing");i=r!=null&&r!=undefined;if(i){if(!Array.isArray(r))throw new Error("missing values for writing");ctCheckReq(e,this.types)}else ctCheckReq(e,this.types,["value"]);this.writeStruct(i?r:getValues(e),e,t,n)},exports.Parser=CTypeParser,exports.toAbs64=toAbs64,exports.toApprox64=toApprox64,exports.parseCTF=parseCTF,exports.ruint8=mod_ctio.ruint8,exports.ruint16=mod_ctio.ruint16,exports.ruint32=mod_ctio.ruint32,exports.ruint64=mod_ctio.ruint64,exports.wuint8=mod_ctio.wuint8,exports.wuint16=mod_ctio.wuint16,exports.wuint32=mod_ctio.wuint32,exports.wuint64=mod_ctio.wuint64,exports.rsint8=mod_ctio.rsint8,exports.rsint16=mod_ctio.rsint16,exports.rsint32=mod_ctio.rsint32,exports.rsint64=mod_ctio.rsint64,exports.wsint8=mod_ctio.wsint8,exports.wsint16=mod_ctio.wsint16,exports.wsint32=mod_ctio.wsint32,exports.wsint64=mod_ctio.wsint64,exports.rfloat=mod_ctio.rfloat,exports.rdouble=mod_ctio.rdouble,exports.wfloat=mod_ctio.wfloat,exports.wdouble=mod_ctio.wdouble